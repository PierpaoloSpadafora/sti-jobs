// StiJobsApplication.java
package unical.demacs.rdm;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.io.File;
import java.nio.file.Paths;

@SpringBootApplication
public class StiJobsApplication {


	private static void createFolder(String path) {
		File logFolder = new File(path);
		if (!logFolder.exists()) {
			if (logFolder.mkdirs()) {
				System.out.println("Cartella di log in: " + path + " creata con successo.");
			} else {
				System.err.println("Impossibile creare la cartella di log in: " + path + ".");
			}
		}
	}

	public static void main(String[] args) {
		String baseDir;
		if (System.getProperty("os.name").toLowerCase().contains("win")) {
			baseDir = "C:\\sti-jobs-logs";
		} else {
			baseDir = "/sti-jobs-logs";
		}

		String backendDir = Paths.get(baseDir, "Backend").toString();

		createFolder(baseDir);
		createFolder(backendDir);
		SpringApplication.run(StiJobsApplication.class, args);
	}

}

// config\ModelMapperConfig.java
package unical.demacs.rdm.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.modelmapper.ModelMapper;

@Configuration
public class ModelMapperConfig {
    @Bean
    public ModelMapper getModelMapper() {
        ModelMapper modelMapper = new ModelMapper();
        return modelMapper;
    }


}
// config\RateLimiterConfig.java
package unical.demacs.rdm.config;


import com.google.common.util.concurrent.RateLimiter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
public class RateLimiterConfig {
    @Bean
    // FIXME - meno richieste
    public RateLimiter rateLimiter(){
        return RateLimiter.create(500000d, Duration.ofSeconds(15));
    }
}

// config\exception\JobException.java
package unical.demacs.rdm.config.exception;

public class JobException extends RuntimeException {
    public JobException(String message) {
        super(message);
    }
}

// config\exception\JobNotFoundException.java
package unical.demacs.rdm.config.exception;

public class JobNotFoundException extends RuntimeException {
    public JobNotFoundException(String message) {
        super(message);
    }
}

// config\exception\MachineException.java
package unical.demacs.rdm.config.exception;

public class MachineException extends RuntimeException {
    public MachineException(String message) {
        super(message);
    }
}

// config\exception\MachineNotFoundException.java
package unical.demacs.rdm.config.exception;

public class MachineNotFoundException extends RuntimeException {
    public MachineNotFoundException(String message) {
        super(message);
    }
}

// config\exception\NoUserFoundException.java
package unical.demacs.rdm.config.exception;

public class NoUserFoundException extends RuntimeException{
    public NoUserFoundException(String message) {
        super(message);
    }
}
// config\exception\ScheduleException.java
package unical.demacs.rdm.config.exception;

public class ScheduleException extends RuntimeException {
    public ScheduleException(String message) {
        super(message);
    }
}

// config\exception\ScheduleNotFoundException.java
package unical.demacs.rdm.config.exception;

public class ScheduleNotFoundException extends RuntimeException {
    public ScheduleNotFoundException(String message) {
        super(message);
    }
}

// config\exception\TooManyRequestsException.java
package unical.demacs.rdm.config.exception;

public class TooManyRequestsException extends RuntimeException{}
// config\exception\UserException.java
package unical.demacs.rdm.config.exception;

public class UserException extends RuntimeException {
    public UserException(String message) { super(message); }
}
// config\exception\handler\ExceptionsHandler.java
package unical.demacs.rdm.config.exception.handler;


import org.springframework.boot.configurationprocessor.json.JSONObject;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import unical.demacs.rdm.config.exception.*;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.Map;

@ControllerAdvice
public class ExceptionsHandler {

    @ExceptionHandler(TooManyRequestsException.class)
    private ResponseEntity<?> handleTooManyRequests() {
        return new ResponseEntity<>(new JSONObject(
                Map.of("message", "Too Many Request")).toString(), HttpStatus.TOO_MANY_REQUESTS);
    }

    @ExceptionHandler(UserException.class)
    private ResponseEntity<?> handleUserExceptionException(UserException ex) {
        return new ResponseEntity<>(new JSONObject(
                Map.of("message", ex.getMessage())).toString(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(NoUserFoundException.class)
    private ResponseEntity<?> handleNoUserFoundExceptionException(NoUserFoundException ex) {
        return new ResponseEntity<>(new JSONObject(
                Map.of("message", ex.getMessage())).toString(), HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(ScheduleNotFoundException.class)
    private ResponseEntity<?> handleScheduleNotFoundExceptionException(ScheduleNotFoundException ex) {
        return new ResponseEntity<>(new JSONObject(
                Map.of("message", ex.getMessage())).toString(), HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(ScheduleException.class)
    private ResponseEntity<?> handleScheduleExceptionException(ScheduleException ex) {
        return new ResponseEntity<>(new JSONObject(
                Map.of("message", ex.getMessage())).toString(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(JobNotFoundException.class)
    private ResponseEntity<?> handleJobNotFoundExceptionException(JobNotFoundException ex) {
        return new ResponseEntity<>(new JSONObject(
                Map.of("message", ex.getMessage())).toString(), HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(JobException.class)
    private ResponseEntity<?> handleJobExceptionException(JobException ex) {
        return new ResponseEntity<>(new JSONObject(
                Map.of("message", ex.getMessage())).toString(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(MachineException.class)
    private ResponseEntity<?> handleMachineExceptionException(MachineException ex) {
        return new ResponseEntity<>(new JSONObject(
                Map.of("message", ex.getMessage())).toString(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(MachineNotFoundException.class)
    private ResponseEntity<?> handleMachineNotFoundExceptionException(MachineNotFoundException ex) {
        return new ResponseEntity<>(new JSONObject(
                Map.of("message", ex.getMessage())).toString(), HttpStatus.NOT_FOUND);
    }

}

// controller\JobController.java
package unical.demacs.rdm.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.AllArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import unical.demacs.rdm.persistence.dto.JobDTO;
import unical.demacs.rdm.persistence.entities.Job;
import unical.demacs.rdm.persistence.service.implementation.JobServiceImpl;

@RestController
@RequestMapping(value = "/api/v1/job", produces = "application/json")
@CrossOrigin
@AllArgsConstructor
@Tag(name = "job-controller", description = "Operations related to job management, include job create, update and delete.")
public class JobController {

    private final JobServiceImpl jobServiceImpl;
    private final ModelMapper modelMapper;

    @Operation(summary = "Create a job", description = "Create a job using the provided job object.",
            tags = {"job-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Job created successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JobDTO.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @PostMapping(value = "/create-job", produces = "application/json")
    public ResponseEntity<JobDTO> createJob(@RequestBody Job job) {
        return ResponseEntity.ok(modelMapper.map(jobServiceImpl.createJob(job), JobDTO.class));
    }

    @Operation(summary = "Update a job", description = "Update a job using the provided job object.",
            tags = {"job-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Job updated successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JobDTO.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @PutMapping(value = "/update-job{id}", produces = "application/json")
    public ResponseEntity<JobDTO> updateJob(@PathVariable("id") Long id, @RequestBody Job job) {
        return ResponseEntity.ok(modelMapper.map(jobServiceImpl.updateJob(id, job), JobDTO.class));
    }

    @Operation(summary = "Get all job", description = "Return all the jobs in the database.",
            tags = {"job-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "All jobs retrieved successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JobDTO.class))),
            @ApiResponse(responseCode = "404", description = "No jobs found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @GetMapping(path="/get-all-jobs/")
    public ResponseEntity<JobDTO> getAllJobs() {
        return ResponseEntity.ok(modelMapper.map(jobServiceImpl.getAllJobs(), JobDTO.class));
    }

    @Operation(summary = "Get job by id", description = "Retrieve a job using their id.",
            tags = {"job-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Job retrieved successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = Job.class))),
            @ApiResponse(responseCode = "404", description = "Job not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @GetMapping(path="/jobs-by-id/{id}")
    public ResponseEntity<JobDTO> getJobById(@PathVariable("id") Long id) {
        return ResponseEntity.ok(modelMapper.map(jobServiceImpl.getJobById(id), JobDTO.class));
    }

    @Operation(summary = "Delete a job", description = "Delete a job using their id.",
            tags = {"job-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Job deleted successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JobDTO.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @DeleteMapping(value = "/delete-job{id}", produces = "application/json")
    public ResponseEntity<JobDTO> deleteJob(@PathVariable("id") Long id) {
        jobServiceImpl.deleteJob(id);
        return ResponseEntity.ok().build();
    }
}

// controller\MachineController.java
package unical.demacs.rdm.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.AllArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import unical.demacs.rdm.persistence.dto.MachineDTO;
import unical.demacs.rdm.persistence.service.implementation.MachineServiceImpl;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping(value = "/api/v1/machine", produces = "application/json")
@CrossOrigin
@AllArgsConstructor
@Tag(name = "machine-controller", description = "Operations related to machine management.")
public class MachineController {

    private final MachineServiceImpl machineServiceImpl;
    private final ModelMapper modelMapper;

    @Operation(summary = "Create a new machine", description = "Create a new machine with specified details.",
            tags = {"machine-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "201", description = "Machine created successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = MachineDTO.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @PostMapping
    public ResponseEntity<MachineDTO> createMachine(@RequestBody MachineDTO machineDTO) {
        MachineDTO createdMachine = modelMapper.map(machineServiceImpl.createMachine(machineDTO), MachineDTO.class);
        return ResponseEntity.status(201).body(createdMachine);
    }

    @Operation(summary = "Update a machine", description = "Update a machine's details by ID.",
            tags = {"machine-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Machine updated successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = MachineDTO.class))),
            @ApiResponse(responseCode = "404", description = "Machine not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @PutMapping(path = "/{id}")
    public ResponseEntity<MachineDTO> updateMachine(@PathVariable("id") Long id, @RequestBody MachineDTO machineDTO) {
        MachineDTO updatedMachine = modelMapper.map(machineServiceImpl.updateMachine(id, machineDTO), MachineDTO.class);
        return ResponseEntity.ok(updatedMachine);
    }

    @Operation(summary = "Get machine by ID", description = "Retrieve a machine using its ID.",
            tags = {"machine-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Machine retrieved successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = MachineDTO.class))),
            @ApiResponse(responseCode = "404", description = "Machine not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @GetMapping(path = "/{id}")
    public ResponseEntity<MachineDTO> getMachineById(@PathVariable("id") Long id) {
        return ResponseEntity.ok(modelMapper.map(machineServiceImpl.getMachineById(id), MachineDTO.class));
    }

    @Operation(summary = "Get all machines", description = "Retrieve all machines.",
            tags = {"machine-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Machines retrieved successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = MachineDTO.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @GetMapping
    public ResponseEntity<List<MachineDTO>> getAllMachines() {
        List<MachineDTO> machines = machineServiceImpl.getAllMachines()
                .stream()
                .map(machine -> modelMapper.map(machine, MachineDTO.class))
                .collect(Collectors.toList());
        return ResponseEntity.ok(machines);
    }

    @Operation(summary = "Delete a machine", description = "Delete a machine by ID.",
            tags = {"machine-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "204", description = "Machine deleted successfully."),
            @ApiResponse(responseCode = "404", description = "Machine not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @DeleteMapping(path = "/{id}")
    public ResponseEntity<Void> deleteMachine(@PathVariable("id") Long id) {
        machineServiceImpl.deleteMachine(id);
        return ResponseEntity.noContent().build();
    }
}

// controller\MachineTypeController.java
package unical.demacs.rdm.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.AllArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import unical.demacs.rdm.config.exception.MachineException;
import unical.demacs.rdm.persistence.dto.MachineTypeDTO;
import unical.demacs.rdm.persistence.service.implementation.MachineTypeServiceImpl;

import java.util.List;

@RestController
@RequestMapping(value = "/api/v1/machine-type", produces = "application/json")
@CrossOrigin
@AllArgsConstructor
@Tag(name = "machine-type-controller", description = "Operations related to machine type management.")
public class MachineTypeController {

    private final MachineTypeServiceImpl machineTypeServiceImpl;

    @Operation(summary = "Create machine type", description = "Create a new machine type.",
            tags = {"machine-type-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Machine type created successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = MachineTypeDTO.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @PostMapping(path="create")
    public ResponseEntity<MachineTypeDTO> createMachineType(@RequestBody MachineTypeDTO machineTypeDTO) {
        return ResponseEntity.ok(machineTypeServiceImpl.createMachineType(machineTypeDTO));
    }

    @Operation(summary = "Get machine type by id", description = "Retrieve a machine type using its id.",
            tags = {"machine-type-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Machine type retrieved successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = MachineTypeDTO.class))),
            @ApiResponse(responseCode = "404", description = "Machine type not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @GetMapping(path="/by-id/{id}")
    public ResponseEntity<MachineTypeDTO> getMachineTypeById(@PathVariable("id") Long id) {
        return ResponseEntity.ok(machineTypeServiceImpl.getMachineTypeById(id)
                .orElseThrow(() -> new MachineException("Machine type not found")));
    }

    @Operation(summary = "Get all machine types", description = "Retrieve all machine types.",
            tags = {"machine-type-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Machine types retrieved successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = MachineTypeDTO.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @GetMapping(path="/get-all")
    public ResponseEntity<List<MachineTypeDTO>> getAllMachineTypes() {
        List<MachineTypeDTO> machineTypes = machineTypeServiceImpl.getAllMachineTypes();
        return ResponseEntity.ok(machineTypes);
    }

    @Operation(summary = "Delete machine type", description = "Delete a machine type using its id.",
            tags = {"machine-type-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "204", description = "Machine type deleted successfully."),
            @ApiResponse(responseCode = "404", description = "Machine type not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @DeleteMapping(path="/by-id/{id}")
    public ResponseEntity<Void> deleteMachineType(@PathVariable("id") Long id) {
        machineTypeServiceImpl.deleteMachineType(id);
        return ResponseEntity.noContent().build();
    }


}

// controller\ScheduleController.java
package unical.demacs.rdm.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import unical.demacs.rdm.persistence.dto.ScheduleDTO;
import unical.demacs.rdm.persistence.enums.ScheduleStatus;
import unical.demacs.rdm.persistence.service.interfaces.IScheduleService;

import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/schedules")
public class ScheduleController {

    private final IScheduleService scheduleService;

    @Autowired
    public ScheduleController(IScheduleService scheduleService) {
        this.scheduleService = scheduleService;
    }

    @PostMapping
    public ResponseEntity<ScheduleDTO> createSchedule(@RequestBody ScheduleDTO scheduleDTO) {
        try {
            ScheduleDTO createdSchedule = scheduleService.createSchedule(scheduleDTO);
            return new ResponseEntity<>(createdSchedule, HttpStatus.CREATED);
        } catch (IllegalArgumentException e) {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
    }

    @GetMapping("/{id}")

    @PatchMapping("/{id}/status")
    public ResponseEntity<ScheduleDTO> updateScheduleStatus(
            @PathVariable Long id,
            @RequestParam String status) {
        try {
            ScheduleStatus newStatus = ScheduleStatus.valueOf(status.toUpperCase());
            ScheduleDTO updatedSchedule = scheduleService.updateScheduleStatus(id, newStatus);
            return new ResponseEntity<>(updatedSchedule, HttpStatus.OK);
        } catch (IllegalArgumentException e) {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        } catch (RuntimeException e) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<ScheduleDTO> updateSchedule(@PathVariable Long id, @RequestBody ScheduleDTO scheduleDTO) {
        try {
            ScheduleDTO updatedSchedule = scheduleService.updateSchedule(id, scheduleDTO);
            return new ResponseEntity<>(updatedSchedule, HttpStatus.OK);
        } catch (RuntimeException e) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    @GetMapping
    public ResponseEntity<List<ScheduleDTO>> getAllSchedules() {
        List<ScheduleDTO> schedules = scheduleService.getAllSchedules();
        return new ResponseEntity<>(schedules, HttpStatus.OK);
    }

    @GetMapping("/status/{status}")
    public ResponseEntity<List<ScheduleDTO>> getSchedulesByStatus(@PathVariable String status) {
        try {
            ScheduleStatus scheduleStatus = ScheduleStatus.valueOf(status.toUpperCase());
            List<ScheduleDTO> schedules = scheduleService.getSchedulesByStatus(scheduleStatus);
            return new ResponseEntity<>(schedules, HttpStatus.OK);
        } catch (IllegalArgumentException e) {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
    }

    @GetMapping("/job/{jobId}")
    public ResponseEntity<List<ScheduleDTO>> getSchedulesByJobId(@PathVariable Long jobId) {
        List<ScheduleDTO> schedules = scheduleService.getSchedulesByJobId(jobId);
        return new ResponseEntity<>(schedules, HttpStatus.OK);
    }

    @GetMapping("/machine/{machineId}")
    public ResponseEntity<List<ScheduleDTO>> getSchedulesByMachineId(@PathVariable Long machineId) {
        List<ScheduleDTO> schedules = scheduleService.getSchedulesByMachineId(machineId);
        return new ResponseEntity<>(schedules, HttpStatus.OK);
    }

    @GetMapping("/timeRange")
    public ResponseEntity<List<ScheduleDTO>> getSchedulesInTimeRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startTime,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endTime) {
        List<ScheduleDTO> schedules = scheduleService.getSchedulesInTimeRange(startTime, endTime);
        return new ResponseEntity<>(schedules, HttpStatus.OK);
    }

    @GetMapping("/availability")
    public ResponseEntity<Boolean> checkTimeSlotAvailability(
            @RequestParam Long machineId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startTime,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endTime) {
        boolean isAvailable = scheduleService.isTimeSlotAvailable(machineId, startTime, endTime);
        return new ResponseEntity<>(isAvailable, HttpStatus.OK);
    }


    @GetMapping("/upcoming")
    public ResponseEntity<List<ScheduleDTO>> getUpcomingSchedules(
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime from) {
        LocalDateTime startTime = from != null ? from : LocalDateTime.now();
        List<ScheduleDTO> schedules = scheduleService.getUpcomingSchedules(startTime);
        return new ResponseEntity<>(schedules, HttpStatus.OK);
    }

    @GetMapping("/past")
    public ResponseEntity<List<ScheduleDTO>> getPastSchedules(
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime until) {
        LocalDateTime endTime = until != null ? until : LocalDateTime.now();
        List<ScheduleDTO> schedules = scheduleService.getPastSchedules(endTime);
        return new ResponseEntity<>(schedules, HttpStatus.OK);
    }


    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteSchedule(@PathVariable Long id) {
        boolean deleted = scheduleService.deleteSchedule(id);
        return new ResponseEntity<>(deleted ? HttpStatus.NO_CONTENT : HttpStatus.NOT_FOUND);
    }

}
// controller\UserController.java
package unical.demacs.rdm.controller;


import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.AllArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import unical.demacs.rdm.persistence.dto.UserDTO;
import unical.demacs.rdm.persistence.service.implementation.UserServiceImpl;

@RestController
@RequestMapping(value = "/api/v1/user", produces = "application/json")
@CrossOrigin
@AllArgsConstructor
@Tag(name = "user-controller", description = "Operations related to user management, include login.")
public class UserController {

    private final UserServiceImpl userServiceImpl;
    private final ModelMapper modelMapper;


    @Operation(summary = "Create user by email", description = "Create a user using their email address.",
            tags = {"user-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "User created successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserDTO.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @PostMapping
    public ResponseEntity<UserDTO> createUser(@RequestBody UserDTO userDTO) {
        return ResponseEntity.ok(modelMapper.map(userServiceImpl.createUser(userDTO.getEmail()), UserDTO.class));
    }

    @Operation(summary = "Get user by email", description = "Retrieve a user using their email address.",
            tags = {"user-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "User retrieved successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserDTO.class))),
            @ApiResponse(responseCode = "404", description = "User not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @GetMapping(path="/by-email/{email}")
    public ResponseEntity<UserDTO> getUserByEmail(@PathVariable("email") String email) {
        return ResponseEntity.ok(modelMapper.map(userServiceImpl.getUserByEmail(email), UserDTO.class));
    }

    @Operation(summary = "Get user by id", description = "Retrieve a user using their id.",
            tags = {"user-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "User retrieved successfully.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserDTO.class))),
            @ApiResponse(responseCode = "404", description = "User not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @GetMapping(path="/by-id/{id}")
    public ResponseEntity<UserDTO> getUserById(@PathVariable("id") String id) {
        return ResponseEntity.ok(modelMapper.map(userServiceImpl.getUserById(id), UserDTO.class));
    }

    // delete user

    @Operation(summary = "Delete user by id", description = "Delete a user using their id.",
            tags = {"user-controller"})
    @ApiResponses({
            @ApiResponse(responseCode = "204", description = "User deleted successfully."),
            @ApiResponse(responseCode = "404", description = "User not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))),
            @ApiResponse(responseCode = "500", description = "Server error. Please try again later.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = String.class)))
    })
    @DeleteMapping(path="/by-id/{id}")
    public ResponseEntity<Void> deleteUserById(@PathVariable("id") String id) {
        userServiceImpl.deleteUserById(id);
        return ResponseEntity.noContent().build();
    }


}

// persistence\dto\JobDTO.java
package unical.demacs.rdm.persistence.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import unical.demacs.rdm.persistence.enums.JobPriority;
import unical.demacs.rdm.persistence.enums.JobStatus;

import java.time.Duration;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class JobDTO {
    private Long id;
    private String title;
    private String description;
    private JobStatus status;
    private UserDTO assignee;
    private JobPriority priority;

    private Duration duration;

    private MachineTypeDTO requiredMachineType;
}
// persistence\dto\MachineDTO.java
package unical.demacs.rdm.persistence.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import unical.demacs.rdm.persistence.enums.MachineStatus;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MachineDTO {
    private Long id;
    private String name;
    private String description;
    private MachineStatus status;
    private Long typeId; // ID per riferire il MachineType
    private String typeName; // Nome per riferire il MachineType (opzionale)
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
// persistence\dto\MachineTypeDTO.java
package unical.demacs.rdm.persistence.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MachineTypeDTO {
    private Long id;
    private String name;
    private String description;
}

// persistence\dto\ScheduleDTO.java
package unical.demacs.rdm.persistence.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ScheduleDTO {

    private Long id;
    private Long jobId;
    private Long machineId;
    private LocalDateTime dueDate;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
// persistence\dto\UserDTO.java
package unical.demacs.rdm.persistence.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;


@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class UserDTO {
    private String id;

    @NotBlank(message = "Email cannot be empty")
    @Email(message = "Provide a valid email address")
    private String email;

}

// persistence\entities\Job.java
package unical.demacs.rdm.persistence.entities;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.time.Duration;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import unical.demacs.rdm.persistence.enums.JobPriority;
import unical.demacs.rdm.persistence.enums.JobStatus;

@Entity
@Table(name = "jobs")
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder(builderMethodName = "buildJob")
public class Job {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column
    private String description;

    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    private JobStatus status;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User assignee;

    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    private JobPriority priority;

    @Column(nullable = false)
    private Duration duration;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "machine_type_id", nullable = false)
    private MachineType requiredMachineType;

}
// persistence\entities\Machine.java
package unical.demacs.rdm.persistence.entities;

import jakarta.persistence.*;
import lombok.Data;
import unical.demacs.rdm.persistence.enums.MachineStatus;

import java.time.LocalDateTime;

@Entity
@Table(name = "machines")
@Data
public class Machine {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String description;

    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    private MachineStatus status;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "type_id", nullable = false)
    private MachineType type;

    @Column(nullable = false)
    private LocalDateTime createdAt;

    @Column
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        status = MachineStatus.AVAILABLE;
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
// persistence\entities\MachineType.java
package unical.demacs.rdm.persistence.entities;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.util.List;

@Entity
@Table(name = "machine_types")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class MachineType {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String name;

    @Column
    private String description;

    @OneToMany(mappedBy = "type", fetch = FetchType.LAZY)
    private List<Machine> machines;

    @OneToMany(mappedBy = "requiredMachineType", fetch = FetchType.LAZY)
    private List<Job> jobs;
}

// persistence\entities\Schedule.java
package unical.demacs.rdm.persistence.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import unical.demacs.rdm.persistence.enums.JobStatus;
import unical.demacs.rdm.persistence.enums.ScheduleStatus;

import java.time.LocalDateTime;

@Entity
@Table(name = "schedules")
@Data

@NoArgsConstructor
@AllArgsConstructor
public class Schedule {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "job_id", nullable = false)
    private Job job;

    @ManyToOne
    @JoinColumn(name = "machine_id", nullable = false)
    private Machine machine;

    @Column
    private LocalDateTime dueDate;

    @Column(nullable = false)
    private LocalDateTime startTime;

    @Column(nullable = false)
    private LocalDateTime endTime;

    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    private ScheduleStatus status;

    @PrePersist
    protected void onCreate() {
        status = ScheduleStatus.SCHEDULED;
        createdAt = LocalDateTime.now();
    }
    @Column(nullable = false)
    private LocalDateTime createdAt;

    @Column
    private LocalDateTime updatedAt;

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

}
// persistence\entities\User.java
package unical.demacs.rdm.persistence.entities;


import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.*;

import java.util.Objects;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder(builderMethodName = "buildUser")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @NotBlank(message = "L'e-mail non può essere vuota")
    @Email(message = "L'e-mail deve essere valida")
    @Column(nullable = false, unique = true)
    private String email;


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User user = (User) o;
        return id.equals(user.id) && email.equals(user.email);
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", email='" + email + '\'' +
                '}';
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, email);
    }
}

// persistence\enums\JobPriority.java
package unical.demacs.rdm.persistence.enums;

public enum JobPriority {
    LOW,
    MEDIUM,
    HIGH,
    URGENT
}
// persistence\enums\JobStatus.java
package unical.demacs.rdm.persistence.enums;

public enum JobStatus {
    PENDING,
    SCHEDULED,
    IN_PROGRESS,
    COMPLETED,
    CANCELLED
}
// persistence\enums\MachineStatus.java
package unical.demacs.rdm.persistence.enums;

public enum MachineStatus {
    AVAILABLE,
    BUSY,
    MAINTENANCE,
    OUT_OF_SERVICE
}
// persistence\enums\ScheduleStatus.java
package unical.demacs.rdm.persistence.enums;

public enum ScheduleStatus {
    SCHEDULED,
    IN_PROGRESS,
    COMPLETED,
    CANCELLED
}
// persistence\repository\JobRepository.java
package unical.demacs.rdm.persistence.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import unical.demacs.rdm.persistence.dto.JobDTO;
import unical.demacs.rdm.persistence.entities.Job;
import unical.demacs.rdm.persistence.enums.JobStatus;
import unical.demacs.rdm.persistence.enums.JobPriority;

import java.util.List;
import java.util.Optional;

@Repository
public interface JobRepository extends JpaRepository<Job, Long> {
    Optional<Job> findByTitle(String title);
    List<Job> findByStatus(JobStatus status);
    List<Job> findByAssignee_Id(String assigneeId);
    List<Job> findByPriority(JobPriority priority);
    List<Job> findByDurationGreaterThan(java.time.Duration duration);
    List<Job> findByRequiredMachineType_Id(Long machineTypeId);
    List<Job> findByPriorityAndStatus(JobPriority priority, JobStatus status);
    List<Job> findByDurationBetween(java.time.Duration minDuration, java.time.Duration maxDuration);
    List<Job> findByAssignee_IdAndPriority(String assigneeId, JobPriority priority);
    List<Job> findByStatusAndRequiredMachineType_IdAndAssignee_Id(JobStatus status, Long machineTypeId, String assigneeId);
}
// persistence\repository\MachineRepository.java
package unical.demacs.rdm.persistence.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import unical.demacs.rdm.persistence.entities.Machine;
import unical.demacs.rdm.persistence.enums.MachineStatus;

import java.util.List;
import java.util.Optional;

public interface MachineRepository extends JpaRepository<Machine, Long> {
    List<Machine> findByStatus(MachineStatus status);
    List<Machine> findByTypeId(Long typeId);
    Optional<Machine> findById(Long id);
}

// persistence\repository\MachineTypeRepository.java
package unical.demacs.rdm.persistence.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import unical.demacs.rdm.persistence.entities.MachineType;

import java.util.Optional;

@Repository
public interface MachineTypeRepository extends JpaRepository<MachineType, Long> {
    Optional<MachineType> findByName(String name);
    Optional<MachineType> findById(Long id);
}

// persistence\repository\ScheduleRepository.java
package unical.demacs.rdm.persistence.repository;

// Repository for Schedule
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import unical.demacs.rdm.persistence.entities.Schedule;
import unical.demacs.rdm.persistence.enums.ScheduleStatus;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface ScheduleRepository extends JpaRepository<Schedule, Long> {
    List<Schedule> findByStatus(ScheduleStatus status);
    List<Schedule> findByJob_Id(Long jobId);
    List<Schedule> findByMachine_Id(Long machineId);
    List<Schedule> findByStartTimeAfter(LocalDateTime startTime);
    List<Schedule> findByEndTimeBefore(LocalDateTime endTime);
    List<Schedule> findByStartTimeBetween(LocalDateTime start, LocalDateTime end);
}
// persistence\repository\UserRepository.java
package unical.demacs.rdm.persistence.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import unical.demacs.rdm.persistence.entities.User;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface UserRepository extends JpaRepository<User, UUID> {
    Optional<User> findByEmail(String email);
    Optional<User> findById(String id);
}

// persistence\service\implementation\JobServiceImpl.java
package unical.demacs.rdm.persistence.service.implementation;

import lombok.AllArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import unical.demacs.rdm.config.exception.UserException;
import unical.demacs.rdm.persistence.dto.JobDTO;
import unical.demacs.rdm.persistence.entities.Job;
import unical.demacs.rdm.persistence.entities.User;
import unical.demacs.rdm.persistence.repository.JobRepository;
import unical.demacs.rdm.persistence.service.interfaces.IJobService;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@AllArgsConstructor
public class JobServiceImpl implements IJobService {


    public static final Logger logger = LoggerFactory.getLogger(JobServiceImpl.class);
    private JobRepository jobRepository;

    @Override
    public Optional<Job> getAllJobs() {
        return Optional.of((Job) jobRepository.findAll());
    }

    @Override
    public Optional<Job> getJobById(Long id) {
        return jobRepository.findById(id);
    }

    @Override
    public Job createJob(Job job) {
        logger.info("++++++START REQUEST++++++");
        logger.info("Attempting to create job with title: {}", job.getTitle());
        try {
            Job new_job = jobRepository.findByTitle(job.getTitle()).orElse(null);
            if (new_job != null) {
                logger.info("Job with title {} already exists", job.getTitle());
                return job;
            } else {
                new_job = Job.buildJob()
                        .title(job.getTitle())
                        .description(job.getDescription())
                        .status(job.getStatus())
                        .priority(job.getPriority())
                        .duration(job.getDuration())
                        .assignee(job.getAssignee())
                        .requiredMachineType(job.getRequiredMachineType())
                        .build();
                jobRepository.save(job);
                logger.info("Job with title {} created successfully", job.getTitle());
                return new_job;
            }
        } catch (Exception e) {
            logger.error("Error creating job with title: {}", job.getTitle(), e);
            throw new UserException("Error creating job");
        } finally {
            logger.info("++++++END REQUEST++++++");
        }
    }

    @Override
    public Optional<Job> updateJob(Long id, Job job) {
        return jobRepository.findById(id).map(existingJob -> {
            existingJob.setTitle(job.getTitle());
            existingJob.setDescription(job.getDescription());
            existingJob.setStatus(job.getStatus());
            existingJob.setPriority(job.getPriority());
            existingJob.setDuration(job.getDuration());
            // Assignee and MachineType mapping can be done here as needed
            return jobRepository.save(existingJob);
        });
    }

    @Override
    public void deleteJob(Long id) {
        jobRepository.deleteById(id);
    }

}
// persistence\service\implementation\MachineServiceImpl.java
package unical.demacs.rdm.persistence.service.implementation;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import unical.demacs.rdm.persistence.dto.MachineDTO;
import unical.demacs.rdm.persistence.entities.Machine;
import unical.demacs.rdm.persistence.entities.MachineType;
import unical.demacs.rdm.persistence.enums.MachineStatus;
import unical.demacs.rdm.persistence.repository.MachineRepository;
import unical.demacs.rdm.persistence.service.interfaces.IMachineService;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class MachineServiceImpl implements IMachineService {

    private final MachineRepository machineRepository;

    @Autowired
    public MachineServiceImpl(MachineRepository machineRepository) {
        this.machineRepository = machineRepository;
    }

    @Override
    public MachineDTO createMachine(MachineDTO machineDTO) {
        Machine machine = convertToEntity(machineDTO);
        machine.setCreatedAt(LocalDateTime.now());
        machine.setStatus(MachineStatus.AVAILABLE); // Impostazione predefinita dello stato
        Machine savedMachine = machineRepository.save(machine);
        return convertToDTO(savedMachine);
    }

    @Override
    public MachineDTO getMachineById(Long id) {
        Machine machine = machineRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Machine not found with id: " + id));
        return convertToDTO(machine);
    }


    @Override
    public MachineDTO updateMachine(Long id, MachineDTO machineDTO) {
        Machine machine = machineRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Machine not found with id: " + id));

        machine.setName(machineDTO.getName());
        machine.setDescription(machineDTO.getDescription());
        machine.setStatus(machineDTO.getStatus());
        machine.setUpdatedAt(LocalDateTime.now());

        // Usa typeId direttamente senza verificare con MachineTypeRepository
        machine.getType().setId(machineDTO.getTypeId());

        Machine updatedMachine = machineRepository.save(machine);
        return convertToDTO(updatedMachine);
    }

    @Override
    public void deleteMachine(Long id) {
        if (!machineRepository.existsById(id)) {
            throw new RuntimeException("Machine not found with id: " + id);
        }
        machineRepository.deleteById(id);
    }

    @Override
    public List<MachineDTO> getAllMachines() {
        return machineRepository.findAll().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    // Metodo per convertire Machine a MachineDTO
    private MachineDTO convertToDTO(Machine machine) {
        MachineDTO dto = new MachineDTO();
        dto.setId(machine.getId());
        dto.setName(machine.getName());
        dto.setDescription(machine.getDescription());
        dto.setStatus(machine.getStatus());
        dto.setTypeId(machine.getType() != null ? machine.getType().getId() : null);
        dto.setTypeName(machine.getType() != null ? machine.getType().getName() : null);
        dto.setCreatedAt(machine.getCreatedAt());
        dto.setUpdatedAt(machine.getUpdatedAt());
        return dto;
    }

    // Metodo per convertire MachineDTO a Machine
    private Machine convertToEntity(MachineDTO machineDTO) {
        Machine machine = new Machine();
        machine.setName(machineDTO.getName());
        machine.setDescription(machineDTO.getDescription());
        machine.setStatus(machineDTO.getStatus());
        machine.setCreatedAt(machineDTO.getCreatedAt());

        // Imposta solo l'ID di MachineType se fornito (senza caricare un oggetto completo)
        if (machineDTO.getTypeId() != null) {
            MachineType machineType = new MachineType();
            machineType.setId(machineDTO.getTypeId());
            machine.setType(machineType);
        }

        return machine;
    }
}

// persistence\service\implementation\MachineTypeServiceImpl.java
package unical.demacs.rdm.persistence.service.implementation;

import lombok.AllArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import unical.demacs.rdm.config.exception.MachineException;
import unical.demacs.rdm.persistence.dto.MachineTypeDTO;
import unical.demacs.rdm.persistence.entities.MachineType;
import unical.demacs.rdm.persistence.repository.MachineTypeRepository;
import unical.demacs.rdm.persistence.service.interfaces.IMachineTypeService;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@AllArgsConstructor
public class MachineTypeServiceImpl implements IMachineTypeService {

    public static final Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);

    private MachineTypeRepository machineTypeRepository;

    @Override
    public MachineTypeDTO createMachineType(MachineTypeDTO machineTypeDTO) {
        logger.info("++++++START REQUEST++++++");
        logger.info("Attempting to create machine type with name: {}", machineTypeDTO.getName());
        try {
            MachineType existingMachineType = machineTypeRepository.findByName(machineTypeDTO.getName()).orElse(null);
            if (existingMachineType != null) {
                logger.info("Machine type with name {} already exists", machineTypeDTO.getName());
                return convertToDTO(existingMachineType);
            }

            MachineType machineType = new MachineType();
            machineType.setName(machineTypeDTO.getName());
            machineType.setDescription(machineTypeDTO.getDescription());
            machineType = machineTypeRepository.save(machineType);
            logger.info("Machine type with name {} created successfully", machineTypeDTO.getName());
            return convertToDTO(machineType);
        } catch (Exception e) {
            logger.error("Error creating machine type with name: {}", machineTypeDTO.getName(), e);
            throw new MachineException("Error creating machine type");
        } finally {
            logger.info("++++++END REQUEST++++++");
        }
    }

    @Override
    public Optional<MachineTypeDTO> getMachineTypeById(Long id) {
        logger.info("++++++START REQUEST++++++");
        logger.info("Attempting to get machine type by id: {}", id);
        try {
            return Optional.ofNullable(machineTypeRepository.findById(id)
                    .map(this::convertToDTO)
                    .orElseThrow(() -> {
                        logger.warn("Machine type not found for id: {}", id);
                        return new MachineException("No machine type found");
                    }));
        } finally {
            logger.info("++++++END REQUEST++++++");
        }
    }

    @Override
    public List<MachineTypeDTO> getAllMachineTypes() {
        logger.info("++++++START REQUEST++++++");
        try {
            return machineTypeRepository.findAll()
                    .stream()
                    .map(this::convertToDTO)
                    .collect(Collectors.toList());
        } finally {
            logger.info("++++++END REQUEST++++++");
        }
    }

    @Override
    public void deleteMachineType(Long id) {
        logger.info("++++++START REQUEST++++++");
        logger.info("Attempting to delete machine type by id: {}", id);
        try {
            if (!machineTypeRepository.existsById(id)) {
                logger.warn("Machine type not found for id: {}", id);
                throw new MachineException("No machine type found");
            }
            machineTypeRepository.deleteById(id);
            logger.info("Machine type with id {} deleted successfully", id);
        } catch (Exception e) {
            logger.error("Error deleting machine type with id: {}", id, e);
            throw new MachineException("Error deleting machine type");
        } finally {
            logger.info("++++++END REQUEST++++++");
        }
    }

    private MachineTypeDTO convertToDTO(MachineType machineType) {
        return new MachineTypeDTO(machineType.getId(), machineType.getName(), machineType.getDescription());
    }
}

// persistence\service\implementation\ScheduleServiceImpl.java
package unical.demacs.rdm.persistence.service.implementation;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import unical.demacs.rdm.persistence.dto.ScheduleDTO;
import unical.demacs.rdm.persistence.entities.Schedule;
import unical.demacs.rdm.persistence.entities.Job;
import unical.demacs.rdm.persistence.entities.Machine;
import unical.demacs.rdm.persistence.enums.ScheduleStatus;
import unical.demacs.rdm.persistence.repository.ScheduleRepository;
import unical.demacs.rdm.persistence.repository.JobRepository;
import unical.demacs.rdm.persistence.repository.MachineRepository;
import unical.demacs.rdm.persistence.service.interfaces.IScheduleService;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Transactional
public class ScheduleServiceImpl implements IScheduleService {

    private final ScheduleRepository scheduleRepository;
    private final JobRepository jobRepository;
    private final MachineRepository machineRepository;

    @Autowired
    public ScheduleServiceImpl(ScheduleRepository scheduleRepository,
                               JobRepository jobRepository,
                               MachineRepository machineRepository) {
        this.scheduleRepository = scheduleRepository;
        this.jobRepository = jobRepository;
        this.machineRepository = machineRepository;
    }

    @Override
    public ScheduleDTO createSchedule(ScheduleDTO scheduleDTO) {
        validateScheduleTime(scheduleDTO);

        Schedule schedule = new Schedule();
        updateScheduleFromDTO(schedule, scheduleDTO);

        Schedule savedSchedule = scheduleRepository.save(schedule);
        return convertToDTO(savedSchedule);
    }

    @Override
    public Optional<ScheduleDTO> getScheduleById(Long id) {
        return scheduleRepository.findById(id)
                .map(this::convertToDTO);
    }

    @Override
    public List<ScheduleDTO> getAllSchedules() {
        return scheduleRepository.findAll().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    public ScheduleDTO updateSchedule(Long id, ScheduleDTO scheduleDTO) {
        Schedule schedule = scheduleRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Schedule not found with id: " + id));

        validateScheduleTime(scheduleDTO);
        updateScheduleFromDTO(schedule, scheduleDTO);

        Schedule updatedSchedule = scheduleRepository.save(schedule);
        return convertToDTO(updatedSchedule);
    }

    @Override
    public boolean deleteSchedule(Long id) {
        if (scheduleRepository.existsById(id)) {
            scheduleRepository.deleteById(id);
            return true;
        }
        return false;
    }

    @Override
    public List<ScheduleDTO> getSchedulesByStatus(ScheduleStatus status) {
        return scheduleRepository.findByStatus(status).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<ScheduleDTO> getSchedulesByJobId(Long jobId) {
        return scheduleRepository.findByJob_Id(jobId).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<ScheduleDTO> getSchedulesByMachineId(Long machineId) {
        return scheduleRepository.findByMachine_Id(machineId).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<ScheduleDTO> getSchedulesInTimeRange(LocalDateTime startTime, LocalDateTime endTime) {
        return scheduleRepository.findByStartTimeBetween(startTime, endTime).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    public boolean isTimeSlotAvailable(Long machineId, LocalDateTime startTime, LocalDateTime endTime) {
        List<Schedule> conflictingSchedules = scheduleRepository.findByMachine_Id(machineId).stream()
                .filter(schedule ->
                        !(schedule.getEndTime().isBefore(startTime) || schedule.getStartTime().isAfter(endTime)))
                .collect(Collectors.toList());

        return conflictingSchedules.isEmpty();
    }

    @Override
    public ScheduleDTO updateScheduleStatus(Long id, ScheduleStatus newStatus) {
        Schedule schedule = scheduleRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Schedule not found with id: " + id));

        schedule.setStatus(newStatus);
        Schedule updatedSchedule = scheduleRepository.save(schedule);
        return convertToDTO(updatedSchedule);
    }

    @Override
    public List<ScheduleDTO> getUpcomingSchedules(LocalDateTime from) {
        return scheduleRepository.findByStartTimeAfter(from).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<ScheduleDTO> getPastSchedules(LocalDateTime until) {
        return scheduleRepository.findByEndTimeBefore(until).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    private ScheduleDTO convertToDTO(Schedule schedule) {
        ScheduleDTO dto = new ScheduleDTO();
        dto.setId(schedule.getId());
        dto.setJobId(schedule.getJob().getId());
        dto.setMachineId(schedule.getMachine().getId());
        dto.setDueDate(schedule.getDueDate());
        dto.setStartTime(schedule.getStartTime());
        dto.setEndTime(schedule.getEndTime());
        dto.setStatus(schedule.getStatus().toString());
        dto.setCreatedAt(schedule.getCreatedAt());
        dto.setUpdatedAt(schedule.getUpdatedAt());
        return dto;
    }

    private void updateScheduleFromDTO(Schedule schedule, ScheduleDTO dto) {
        Job job = jobRepository.findById(dto.getJobId())
                .orElseThrow(() -> new RuntimeException("Job not found with id: " + dto.getJobId()));
        Machine machine = machineRepository.findById(dto.getMachineId())
                .orElseThrow(() -> new RuntimeException("Machine not found with id: " + dto.getMachineId()));

        schedule.setJob(job);
        schedule.setMachine(machine);
        schedule.setDueDate(dto.getDueDate());
        schedule.setStartTime(dto.getStartTime());
        schedule.setEndTime(dto.getEndTime());
        schedule.setStatus(ScheduleStatus.valueOf(dto.getStatus()));
    }

    private void validateScheduleTime(ScheduleDTO dto) {
        if (dto.getStartTime().isAfter(dto.getEndTime())) {
            throw new IllegalArgumentException("Start time must be before end time");
        }
        if (dto.getDueDate() != null && dto.getEndTime().isAfter(dto.getDueDate())) {
            throw new IllegalArgumentException("End time must be before or equal to due date");
        }
        if (!isTimeSlotAvailable(dto.getMachineId(), dto.getStartTime(), dto.getEndTime())) {
            throw new IllegalArgumentException("Time slot is not available for the selected machine");
        }
    }
}
// persistence\service\implementation\UserServiceImpl.java
package unical.demacs.rdm.persistence.service.implementation;

import com.google.common.util.concurrent.RateLimiter;
import lombok.AllArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import unical.demacs.rdm.config.exception.NoUserFoundException;
import unical.demacs.rdm.config.exception.TooManyRequestsException;
import unical.demacs.rdm.config.exception.UserException;
import unical.demacs.rdm.persistence.entities.User;
import unical.demacs.rdm.persistence.repository.UserRepository;
import unical.demacs.rdm.persistence.service.interfaces.IUserService;

import java.util.Optional;

@Service
@AllArgsConstructor
public class UserServiceImpl implements IUserService {

    public static final Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);

    private UserRepository userRepository;
    private final RateLimiter rateLimiter;

    @Override
    public User createUser(String email) {
        logger.info("++++++START REQUEST++++++");
        logger.info("Attempting to create user with email: {}", email);
        try {
            User user = userRepository.findByEmail(email).orElse(null);
            if (user != null) {
                logger.info("User with id {} already exists", email);
                return user;
            } else {
                user = User.buildUser()
                        .email(email)
                        .build();
                userRepository.save(user);
                logger.info("User with email {} created successfully", email);
                return user;
            }
        } catch (Exception e) {
            logger.error("Error creating user with email: {}", email, e);
            throw new UserException("Error creating user");
        } finally {
            logger.info("++++++END REQUEST++++++");
        }
    }

    @Override
    public Optional<User> getUserByEmail(String email) {
        logger.info("++++++START REQUEST++++++");
        logger.info("Attempting to get user by email: {}", email);
        try {
            if (!rateLimiter.tryAcquire()) {
                logger.warn("Rate limit exceeded for getUserByEmail");
                throw new TooManyRequestsException();
            }

            return Optional.ofNullable(userRepository.findByEmail(email)
                    .map(user -> {
                        logger.info("User found: {}", user);
                        return user;
                    })
                    .orElseThrow(() -> {
                        logger.warn("User not found for email: {}", email);
                        return new NoUserFoundException("No user found");
                    }));
        } finally {
            logger.info("++++++END REQUEST++++++");
        }
    }

    @Override
    public Optional<User> getUserById(String id) {
        logger.info("++++++START REQUEST++++++");
        logger.info("Attempting to get user by email: {}", id);
        try {
            if (!rateLimiter.tryAcquire()) {
                logger.warn("Rate limit exceeded for getUserByEmail");
                throw new TooManyRequestsException();
            }

            return Optional.ofNullable(userRepository.findById(id)
                    .map(user -> {
                        logger.info("User found: {}", user);
                        return user;
                    })
                    .orElseThrow(() -> {
                        logger.warn("User not found for id: {}", id);
                        return new NoUserFoundException("No user found");
                    }));
        } finally {
            logger.info("++++++END REQUEST++++++");
        }
    }

    @Override
    public void deleteUserById(String id) {
        logger.info("++++++START REQUEST++++++");
        logger.info("Attempting to delete user by id: {}", id);
        try {
            if (!rateLimiter.tryAcquire()) {
                logger.warn("Rate limit exceeded for deleteUserById");
                throw new TooManyRequestsException();
            }

            userRepository.findById(id)
                    .ifPresentOrElse(user -> {
                        userRepository.delete(user);
                        logger.info("User with id {} deleted successfully", id);
                    }, () -> {
                        logger.warn("User not found for id: {}", id);
                        throw new NoUserFoundException("No user found");
                    });
        } finally {
            logger.info("++++++END REQUEST++++++");
        }
    }
}

// persistence\service\interfaces\IJobService.java
package unical.demacs.rdm.persistence.service.interfaces;

import unical.demacs.rdm.persistence.dto.JobDTO;
import unical.demacs.rdm.persistence.entities.Job;

import java.util.List;
import java.util.Optional;

public interface IJobService {
    Optional<Job> getAllJobs();
    Optional<Job> getJobById(Long id);
    Job createJob(Job job);
    Optional<Job> updateJob(Long id, Job job);
    void deleteJob(Long id);
}

// persistence\service\interfaces\IMachineService.java
package unical.demacs.rdm.persistence.service.interfaces;

import unical.demacs.rdm.persistence.dto.MachineDTO;
import java.util.List;

public interface IMachineService {
    MachineDTO createMachine(MachineDTO machineDTO);
    MachineDTO getMachineById(Long id);
    MachineDTO updateMachine(Long id, MachineDTO machineDTO);
    void deleteMachine(Long id);
    List<MachineDTO> getAllMachines();
}
// persistence\service\interfaces\IMachineTypeService.java
package unical.demacs.rdm.persistence.service.interfaces;

import unical.demacs.rdm.persistence.dto.MachineTypeDTO;

import java.util.List;
import java.util.Optional;

public interface IMachineTypeService {
    MachineTypeDTO createMachineType(MachineTypeDTO machineTypeDTO);
    Optional<MachineTypeDTO> getMachineTypeById(Long id);
    List<MachineTypeDTO> getAllMachineTypes();
    void deleteMachineType(Long id);
}

// persistence\service\interfaces\IScheduleService.java
package unical.demacs.rdm.persistence.service.interfaces;

import unical.demacs.rdm.persistence.dto.ScheduleDTO;
import unical.demacs.rdm.persistence.enums.ScheduleStatus;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

public interface IScheduleService {
    ScheduleDTO createSchedule(ScheduleDTO scheduleDTO);
    Optional<ScheduleDTO> getScheduleById(Long id);
    List<ScheduleDTO> getAllSchedules();
    ScheduleDTO updateSchedule(Long id, ScheduleDTO scheduleDTO);
    boolean deleteSchedule(Long id);

    List<ScheduleDTO> getSchedulesByStatus(ScheduleStatus status);
    List<ScheduleDTO> getSchedulesByJobId(Long jobId);
    List<ScheduleDTO> getSchedulesByMachineId(Long machineId);
    List<ScheduleDTO> getSchedulesInTimeRange(LocalDateTime startTime, LocalDateTime endTime);
    boolean isTimeSlotAvailable(Long machineId, LocalDateTime startTime, LocalDateTime endTime);
    ScheduleDTO updateScheduleStatus(Long id, ScheduleStatus newStatus);
    List<ScheduleDTO> getUpcomingSchedules(LocalDateTime from);
    List<ScheduleDTO> getPastSchedules(LocalDateTime until);
}
// persistence\service\interfaces\IUserService.java
package unical.demacs.rdm.persistence.service.interfaces;

import jakarta.transaction.Transactional;
import unical.demacs.rdm.persistence.entities.User;

import java.util.Optional;

public interface IUserService {
    @Transactional
    User createUser(String email);

    Optional<User> getUserByEmail(String email);
    Optional<User> getUserById(String id);
    void deleteUserById(String id);
}

